{{ self.title() }}

{{ s('description') }}

Linux用户和OSX用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu使用的apt-get，Fedora/CentOS使用的yum，以及OSX下可用的homebrew都是优秀的软件包管理器。

你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包$A$依赖软件包$B$，那么安装软件包$A$以前，必须先安装软件包$B$。同时，如果想要卸载软件包$B$，则必须卸载软件包$A$。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除0号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而0号软件包不依赖任何一个软件包。依赖关系不存在环（若有$m(m\ge 2)$个软件包$A_1,A_2,A_3,⋯,A_m$，其中$A_1$依赖$A_2$，$A_2$依赖$A_3$，$A_3$依赖$A_4$，……，$A_{m-1}$依赖$A_m$，而$A_m$依赖$A_1$，则称这$m$个软件包的依赖关系构成环），当然也不会有一个软件包依赖自己。

现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。**注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为0。**

{{ s('input format') }}

{{ self.input_file() }}

输入文件的第1行包含1个整数$n$，表示软件包的总数。软件包从0开始编号。

随后一行包含$n−1$个整数，相邻整数之间用单个空格隔开，分别表示$1,2,3,⋯,n−2,n−1$号软件包依赖的软件包的编号。

接下来一行包含1个整数$q$，表示询问的总数。之后$q$行，每行1个询问。询问分为两种：

- install x：表示安装软件包x

- uninstall x：表示卸载软件包x

你需要维护每个软件包的安装状态，一开始所有的软件包都处于未安装状态。

对于每个操作，你需要输出这步操作会改变多少个软件包的安装状态，随后应用这个操作（即改变你维护的安装状态）。

{{ s('output format') }}

{{ self.output_file() }}

输出文件包括$q$行。

输出文件的第$i$行输出1个整数，为第$i$步操作中改变安装状态的软件包数。

{{ s('sample', 1) }}

{{ self.sample_text() }}

{{ render(json.dumps('\\clearpage'), 'noi') }}

{{ self.title_sample_description() }}



一开始所有的软件包都处于未安装状态。

安装5号软件包，需要安装0,1,5三个软件包。

之后安装6号软件包，只需要安装6号软件包。此时安装了0,1,5,6四个软件包。

卸载1号软件包需要卸载1,5,6三个软件包。此时只有0号软件包还处于安装状态。

之后安装4号软件包，需要安装1,4两个软件包。此时0,1,4处在安装状态。最后，卸载0号软件包会卸载所有的软件包。

{{ img('sample2.png', size = 1, align = 'middle', inline = False) }}

{{ s('sample', 2) }}

{{ self.sample_text() }}


{{ s('subtasks') }}

{{ img('sample.png', size = 1, align = 'middle', inline = False) }}